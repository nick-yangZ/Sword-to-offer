#include <cstdio>
#include <fstream>
#include "BinaryTree.h"
using namespace std;
//面试题39-数组中出现次数超过一半的数字
//解法一利用快速排序法找出此数。

int FindTheMostnumber(int *pHead,int length) {
	if (pHead == nullptr || length <= 0)
		return 0;
	int middle = length >> 1;
	int temp = pHead[middle];
	int end = length - 1;
	pHead[middle] = pHead[end];
	pHead[end] = temp;
	int *pDivide=pHead, *pPass= pHead,*pDivideEqual=pHead;
	while (*pDivide < pHead[end])
		pDivide++;
	pDivideEqual = pDivide;
	while (*pDivideEqual <= pHead[end]&&pDivideEqual<pHead+end)
		pDivideEqual++;
	pPass = pDivideEqual;
	while (pPass < pHead+end) {
		if (*pPass <= pHead[end]) {
			temp = *pPass;
			*pPass = *pDivideEqual;
			*pDivideEqual = temp;
			
			if (*pDivideEqual < pHead[end]) {
				*pDivideEqual = *pDivide;
				*pDivide = temp;
				pDivide++;
			}
			pDivideEqual++;
		}
		pPass++;
	}
	temp = *pDivideEqual;
	*pDivideEqual = pHead[end];
	pHead[end] = temp;
	if (*pDivideEqual == pHead[middle])
		return *pDivideEqual;
	else if (*pDivideEqual < pHead[middle])
		return FindTheMostnumber(pDivideEqual + 1, pPass - pDivideEqual);
	else if (*pDivide > pHead[middle])
		return FindTheMostnumber(pHead, pDivide - pHead );
	return 0;
}

int main() {
	int Number[17] = { 1,2,3,4,5,5,5,5,2,5,5,5,5,6,7,8,9 };
	int nMostNumber=FindTheMostnumber(Number, 17);

	return 0;
}


